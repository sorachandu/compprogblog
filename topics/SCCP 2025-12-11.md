コンテストのリンク:
https://kenkoooo.com/atcoder/#/contest/show/2057bb39-9a4f-40ce-a079-de4aa701765a

---
## A - QQ solver
https://atcoder.jp/contests/abc232/tasks/abc232_a

入力を文字列で受け取って、0文字目と2文字目をそれぞれ数値に変換してから計算しましょう。
文字型(`char`)から数値型へ変換する場合、適切な文字を引いてやるとよいです (ascii codeの利用)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string S;
    cin>>S;
    int a=S[0]-'0';
    int b=S[2]-'0';
    cout<<a*b<<"\n";
}
```

---
## B - Not Overflow
https://atcoder.jp/contests/abc237/tasks/abc237_a

問題文の通り、与えられた整数 $N$ について $-2^{31} \leq N < 2^{31}$ が成り立つか判定すればよいです。
ただし、 $2^{31}$ も $N$ も符号付き32bit整数型 (`int`など) には収まらずオーバーフローしてしまうので、符号付き64bit整数型 (`long long`など) で管理しましょう。

また、 $2^{k}$ は 左ビットシフト演算を用いて `1<<k` と表すことができますが、 $2^{k}$ が符号付き32bit整数型で扱える範囲を超えた場合オーバーフローしてしまいます。
左辺 $1$ を $1ll$ としてやると、計算過程でも符号付き64bit整数型として扱われるのでオーバーフローを回避できます (整数リテラルという機能です)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long N;
    cin>>N;
    long long M=1ll<<31;
    if(-M<=N and N<M) cout<<"Yes\n";
    else cout<<"No\n";
}
```

---
## C - Mex
https://atcoder.jp/contests/abc245/tasks/abc245_b

$MEX(S) := 集合Sに含まれない最小の非負整数$
として、たまに他の問題で