コンテストのリンク:
https://kenkoooo.com/atcoder/#/contest/show/2057bb39-9a4f-40ce-a079-de4aa701765a

---
## A - QQ solver
https://atcoder.jp/contests/abc232/tasks/abc232_a

入力を文字列で受け取って、0文字目と2文字目をそれぞれ数値に変換してから計算しましょう。
文字型(`char`)から数値型へ変換する場合、適切な文字を引いてやるとよいです (ascii codeの利用)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string S;
    cin>>S;
    int a=S[0]-'0';
    int b=S[2]-'0';
    cout<<a*b<<"\n";
}
```

---
## B - Not Overflow
https://atcoder.jp/contests/abc237/tasks/abc237_a

問題文の通り、与えられた整数 $N$ について $-2^{31} \leq N < 2^{31}$ が成り立つか判定すればよいです。
ただし、 $2^{31}$ も $N$ も符号付き32bit整数型 (`int`など) には収まらずオーバーフローしてしまうので、符号付き64bit整数型 (`long long`など) で管理しましょう。

また、 $2^{k}$ は 左ビットシフト演算を用いて `1<<k` と表すことができますが、 $2^{k}$ が符号付き32bit整数型で扱える範囲を超えた場合オーバーフローしてしまいます。
左辺 $1$ を $1ll$ としてやると、計算過程でも符号付き64bit整数型として扱われるのでオーバーフローを回避できます (整数リテラルという機能です)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long N;
    cin>>N;
    long long M=1ll<<31;
    if(-M<=N and N<M) cout<<"Yes\n";
    else cout<<"No\n";
}
```

---
## C - Mex
https://atcoder.jp/contests/abc245/tasks/abc245_b

長さ $N$ の非負整数列 $A$ に出現しない最小の非負整数を求める問題です。

今回は $A_i$ の値域が $0 \leq A_i \leq 2000$ であるから、長さ2001の`bool`配列を用意して、その要素が出現したかどうかを記録すればよいです。
$A$ について走査して $A$ に出現した要素を記録しておき、その後 $i=0,1,...,2000$ について出現しなかった最小の $i$ を全探索で求めます。その $i$ がそのまま答えです。

このように、取りうる値全てに対して予め配列を用意して管理する手法を**バケット**と呼ぶことがあります (競プロ以外ではあまり使わないかも。バケットソートが由来そう)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    vector<int> seen(2001,false);
    for(int i=0;i<N;i++){
        int a;
        cin>>a;
        seen[a]=true;
    }
    for(int i=0;i<=2000;i++){
        if(seen[i]==false){
            cout<<i<<"\n";
            return 0;
        }
    }
}
```

バケットの考え方を利用せずとも、 $i=0,1,...2000$ について、その $i$ が $A$ に含まれているか全探索で調べてもよいです。
こちらのほうが直感的かもしれませんが、計算量は悪化します (上のバケットを用いた解は$O(N+\max(A)$ で、後者の全探索解は $O(N\max(A)$ 。後者の解法でも本問の制約上ACを得られるが)。

ちなみに、今回問われた操作 (含まれない最小の非負整数を…) は、
MEX($S$) := 集合 $S$ に含まれない最小の非負整数
のような具合で、他の問題文中にそのまま出てくることがある概念です。MEXはMinimal EXcludedの略らしい?
この問題は解法ごと頭に入れておいてよいと思います。

---

## D - abc285_brutmhyhiizp
https://atcoder.jp/contests/abc285/tasks/abc285_c

A=1, B=2, C=3, ... Y=25, Z=26 と割り振ったうえで、IDを26進数表記されたものとして捉えるとうまくいきます。
問題IDの定義を追うよりも、サンプルなど参考にしながら実例を考えたほうがわかりやすいかもしれません。

結局、26進数を10進数に変換するプログラムを書けばよいということになります。
具体的には、**後ろ側の文字から順に** $i=0,1,...|S|-1$ として $S_i・26^i$ を足し合わせた値が10進数への変換結果となります(コードを参照)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string S;
    cin>>S;
    auto f=[](char c){
        return c-'A'+1;
    };
    long long ans=0;
    long long powval=1;
    for(int i=ssize(S);i--;){
        ans+=f(S[i])*powval;
        powval*=26;
    }
    cout<<ans<<"\n";
}
```

---

## E - Yamanote Line Game
https://atcoder.jp/contests/abc244/tasks/abc244_c

**インタラクティブ問題**という、普段とは異なる形式の問題です。
(少なくともABCでは) あまり問われることはないのですが、知らないと戸惑う形式だと思うので、予め知っておきましょうという意図での出題です。

普通の問題ならば、ジャッジ側から入力を一括に渡されて、それに対する答えを出力すればよいのですが、インタラクティブ問題では入力→出力→それに対する入力→… という風にジャッジと提出プログラムが対話する形式で進みます。

大きな注意点としては、出力を行うごとに標準出力のflushが必要な点です。
C++なら`std::endl`を用いれば改行と共にflushしてくれるので、普段通り書けるかもしれません(どちらかといえば `std:⁠:flush` のほうが適切かも)。
C言語でも`fflush`を用いるとflushできます。その他言語でも何かしらflushする方法は用意されていると思うので、各自調べてください。


問題自体は、まだお互いが言ってない整数を出力し続ければ必ず勝てるので、そのようにします。こちらの出力だけでなく、相手からの入力も記録することを忘れずに。
C問題で登場した、バケットの考え方を用いて管理するのが簡便でしょう。
毎回 $i=1,2,...2N+1$ について発言されたことがあるかを調べる $O(N^2)$ 解法でも、本問の制約上ACを得ることができます。
(入力に対して適切に1対1で対応した整数を得られる操作を考えると $O(N)$ でも解けます。ゲーム問題典型であるところの真似っこ戦術 (絶対これ正式名称じゃないな…) に相当するものです)

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    const int siz=2*N+2;
    vector<int> seen(siz,false);
    while(true){
        for(int i=1;i<siz;i++){
            if(seen[i]==false){
                cout<<i<<endl;
                seen[i]=true;
                break;
            }
        }
        int res;
        cin>>res;
        if(res==0) return 0;
        seen[res]=true;
    }
}
```

---

## F - Jumping Takahashi
https://atcoder.jp/contests/abc240/tasks/abc240_c

**DP (動的計画法)** と呼ばれる典型的なアルゴリズムの入門問題です。
DP自体の解説は検索すればいくらでも参考になる教材が出てくるので、そちらに譲ります。

$a_i$ だけ飛ぶか $b_i$ だけ飛ぶか、で2択がN回問われる構造になっていて、全体としては $2^N$ 通りの操作が考えられます。 最悪ケースでは $N=100$ なので、$2^N = 1,267,650,600,228,229,401,496,703,205,376 \fallingdotseq 10^{30}$  
と通り数がとんでもないことになります。

ここで、以下のことに注目します。
- これまでどのようにジャンプしてきたかにかかわらず、今いる座標が同じ「状態」は同一視してもよい
- 座標がXを超えるようなジャンプ方法は無視してよい (正の方向にしかジャンプできないから、最終的な座標がXになることがあり得ない。よって今回の問題では興味がない)
すると、これまたバケットの要領で、 $i=0,1,..X$ について 座標 $i$ に位置できるかを配列で管理してやれば、現実的な実行時間で解を求められるようになるといえます。

$dp[i][j] := i番目のジャンプ直後に、座標jに位置できるか$ 

このようなbool配列を持てば管理できます。計算量は $O(NX)$ です。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int N,X;
    cin>>N>>X;
    vector<int> A(N),B(N);
    for(int i=0;i<N;i++) cin>>A[i]>>B[i];
    vector<int> dp(X+1,false);
    dp[0]=true;
    for(int i=0;i<N;i++){
        vector<int> ndp(X+1,false);
        for(int j=0;j<X;j++){
            if(dp[j]==false) continue;
            if(j+A[i]<=X) ndp[j+A[i]]=true;
            if(j+B[i]<=X) ndp[j+B[i]]=true;
        }
        dp=std::move(ndp);
    }
    if(dp[X]) cout<<"Yes\n";
    else cout<<"No\n";
}
```

DPは競プロにおいて頻出 of 頻出なアルゴリズムなので (というか概念として広範すぎる…)、少しずつしっかりと慣れていくほうがよいです。
[EDPC (Educational DP Contest)](https://atcoder.jp/contests/dp) というコンテストにはDPの練習問題が数多く収録されており、練習に最適です。まずは、これのA-E問題までは理解しておくとよいと思います。

---

