コンテストのリンク:
https://kenkoooo.com/atcoder/#/contest/show/5a033350-3c01-4af0-9b70-3e7119abd133

---

今回のテーマは、「アルゴリズムとデータ構造」で学んだアルゴリズムのうち、競技プログラミング分野でも非常に頻出なものを練習できる回 です

---
## A - Restaurant Queue
https://atcoder.jp/contests/abc402/tasks/abc402_b

問題文で要求されている操作はそれぞれ `enqueue`, `dequeue` に相当していて、データ構造の**Queue**で処理できることがわかります。
具体的には、タイプ1のクエリではメニュー番号 $X$ を`enqueue`し、タイプ2のクエリでは`dequeue`して得られた結果(番号)を出力すればよいです。

`Queue`は大抵の言語の標準ライブラリに収録されているので、それを利用するのが簡便でしょう。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int Q;
    cin>>Q;
    queue<int> que;
    while(Q--){
        int type;
        cin>>type;
        if(type==1){
            int X;
            cin>>X;
            que.push(X);
        }else if(type==2){
            cout<<que.front()<<"\n";
            que.pop();
        }
    }
}
```
https://atcoder.jp/contests/abc402/submissions/72637029

---
##  B - KEYENCE building
https://atcoder.jp/contests/abc227/tasks/abc227_b

問題文中の図が奇妙な見た目をしていますが、結局以下のような問題になっています:
> 整数 $S$ が与えられる。ある正の整数$a$,$b$を用いて $S = 4ab + 3a + 3b$ で表せるか?

$a$, $b$ をそれぞれ $1 \leq a,b \leq S$ の範囲で全探索して、条件を満たすものがあるか判定すればよいです。
これは $O(S^2)$ となりますが、Sは最大で $10^3$ ですから十分高速に判定できます。

この問題を $S_1, \dots ,S_N$ それぞれ解く必要がありますが、Nも小さいので高速に動作します。
とりあえずナイーブな全探索解法を考えると見通しがよくなることがしばしばあります。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    int ans=0;
    for(int i=0;i<N;i++){
        int S;
        cin>>S;
        bool islie=true;
        for(int a=1;a<S;a++){
            for(int b=1;b<S;b++){
                if(4*a*b+3*a+3*b == S){
                    islie=false;
                    a=S; break; // aのループごとbreak
                }
            }
        }
        if(islie) ans++;
    }
    cout<<ans<<"\n";
}
```
https://atcoder.jp/contests/abc227/submissions/72637094

---

ここから難易度がやや上がります。
典型的なアルゴリズムを利用しないと解けない問題になってきます。

---
## C - Abundant Resources
https://atcoder.jp/contests/nikkei2019-final/tasks/nikkei2019_final_a

**累積和**と呼ばれる典型アルゴリズムの練習問題です。

累積和は、長さ $N$ の数列に対して、 $O(N)$ で前計算することにより、任意の区間和を $O(1)$ で取得できるようにする手法です。

詳細を知りたい場合、例えば以下のサイトが参考になるでしょう。
https://algo-logic.info/range-sum-query-without-update/

さて、本問では $k=1, \dots , N$ それぞれについて 長さ $k$ の区間和の最大値を求める必要があります。
これは、累積和を用いて任意の区間和を $O(1)$ で取得できるようにしておくと、各問題が殆どナイーブな全探索の要領で解けることがわかります。

具体的には、長さ $k$ の連続する区間というのは $N-k+1$ 個存在しているので、それらを全探索すればよいです。
それぞれの区間の左端 $i$ を固定し、対応する右端 $i+k$ を取ればそれが長さ $k$ の区間に対応する、といった具合です。
計算量は全体 $O(N^2)$ となって、本問の制約下では十分高速に動作します。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    vector<long long> A(N);
    for(auto &e:A) cin>>e;
    vector<long long> ac(N+1,0);
    for(int i=0;i<N;i++) ac[i+1]=ac[i]+A[i];
    for(int k=1;k<=N;k++){
        long long ans=0;
        for(int i=0;i<=N-k;i++){
            long long sum=ac[i+k]-ac[i];
            if(ans<sum) ans=sum;
        }
        cout<<ans<<"\n";
    }
}
```
https://atcoder.jp/contests/nikkei2019-final/submissions/72637480

---
## D - Enumerate Sequences
https://atcoder.jp/contests/abc367/tasks/abc367_c

一見すると、出力すべき数列自体はforループを用いれば列挙できそうな見た目をしています。
しかし実際にはN重ループが必要になるので、単にループを書くだけで実装するのは現実的ではありません。

こういった場面では**再帰関数**が有用です。再帰関数を用いてやれば現実的に(簡潔に)実装することができます。

再帰関数の書き方については以下の記事が参考になると思います。
https://drken1215.hatenablog.com/entry/2020/05/04/190252

また、競技プログラミングにおいては **深さ優先探索(DFS)** と再帰関数はしばしば同一視されます。
再帰関数を用いた実装は、不慣れなうちは難しいですが、累積和同様に非常に頻出です。
是非とも練習を重ねて、自分なりの書き方や解釈を見つけてもらえればと思います。

#### 実装例
ここでは、ラムダ式を用いて再帰関数を実装しています。
ラムダ式を用いて実装すると、グローバル変数に変数宣言したり、多くの変数を参照渡ししたりせずとも書けるので(参照キャプチャ機能による)、引数がスッキリとして書きやすいと思っています。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N,K;
    cin>>N>>K;
    vector<int> R(N);
    for(auto &e:R) cin>>e;
    auto dfs=[&](this auto self,vector<int> &A,int r) -> void {
        if(r==N){
            int sum=0;
            for(auto &&e:A) sum+=e;
            if(sum%K==0){
                for(int i=0;i<N;i++) cout<<A[i]<<" \n"[i+1==N];
            }
            return;
        }
        for(int i=1;i<=R[r];i++){
            A.emplace_back(i);
            self(A,r+1);
            A.pop_back();
        }
    };
    vector<int> A{};
    dfs(A,0);
}
```
https://atcoder.jp/contests/abc367/submissions/72637447

---
## E - Peak
https://atcoder.jp/contests/abc326/tasks/abc326_c

**二分探索** の練習問題です。

初期状態では、プレゼントの配置を示す配列 $A$ がバラバラになっています。昇順でないと扱いづらいので、とりあえずソートしておきましょう。
(入力等をソートしても解に影響が無さそうであれば、とりあえずソートして考えるのも典型的な思考法です。あまり教育的な発言ではないですが…)

さて、区間を指定してプレゼントを回収するわけですが、明らかに指定する区間の左端は何らかのプレゼントと重ねたほうが得そうです。

> これを直感的に説明します。左端をあるプレゼントに重ねた状態を考えましょう。
そこから、左端が別のプレゼントに重なるまでの間、左端を少しずつ左にずらすことを考えます。
この左にじわじわずらす操作で、新しくプレゼントを得られるでしょうか？
左端側は「別のプレゼントに重なるまで」という定義から、新しくプレゼントを得られるはずがありません。
右端側も、左に動くことで新しくプレゼントを得られることはないです (むしろ、ずらす前は区間に内包していたプレゼントを逃してしまう場合があります)。
よって、左端と一番左のプレゼントの間に空間をとる必要はなく、重ねてよいということになります。

ということで、区間の左端の候補は高々 $N$ 個といえます。 $A_1, \dots , A_N$ のいずれかに一致するようにとればよいから、左端は全探索できます。
左端 $X$ を固定したとき、その左端の位置から $M$ だけ右に伸ばしたら対応する右端 $X+M$ も得られます。

累積和と同じような要領で、
$X+M$ 未満の座標に存在するプレゼントの個数 - $X$ 以下の座標に存在するプレゼントの個数
とすると、対応する区間に存在するプレゼントの個数が求まります。

$X$ 以下のプレゼントの個数は、全探索しているインデックスがそのまま対応しています。
$X + M$ 未満のプレゼントの個数はどうでしょうか？ここで、二分探索の出番です。
整列された長さ $N$ の数列に対して、ある整数がどこに位置するかを求めるのは二分探索によって $O(logN)$ で達成できます。

よって、全体 $O(NlogN)$ で解くことができ、これは本問の制約下で十分高速です。
このような用途の二分探索は、C++では `std::upper_bound`、Pythonでは `bisect_right` のように標準ライブラリに搭載されていることも多いです。
これまた超頻出なので、使いこなせるようにしておきましょう。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N,M;
    cin>>N>>M;
    vector<int> A(N);
    for(auto &e:A) cin>>e;
    ranges::sort(A);
    int ans=0;
    for(int i=0;i<N;i++){
        int r=ranges::lower_bound(A,A[i]+M)-A.begin();
        if(ans<(r-i)) ans=r-i;
    }
    cout<<ans<<"\n";
}
```
https://atcoder.jp/contests/abc326/submissions/72637539

---
## F - Step Up Robot
https://atcoder.jp/contests/abc289/tasks/abc289_d

**動的計画法 (DP)** の練習問題です。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    vector<int> A(N);
    for(auto &e:A) cin>>e;
    int M;
    cin>>M;
    vector<int> B(M);
    for(auto &e:B) cin>>e;
    int X;
    cin>>X;
    vector<bool> hasmochi(X+1,false);
    for(auto e:B) hasmochi[e]=true;
    vector<int> dp(X+1,0);
    dp[0]=1;
    for(int i=0;i<X;i++){
        if(dp[i]==false) continue;
        if(hasmochi[i]) continue;
        for(int j=0;j<N;j++){
            if(i+A[j]>X) break;
            dp[i+A[j]]=true;
        }
    }
    cout<<(dp[X]?"Yes\n":"No\n");
}
```
https://atcoder.jp/contests/abc289/submissions/72637621

---
## G - Add One Edge
https://atcoder.jp/contests/abc309/tasks/abc309_d

**幅優先探索 (BFS)** の練習問題です。

#### 実装例
2回BFSをすることになるので、関数にしておくと綺麗になると思います。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N1,N2,M;
    cin>>N1>>N2>>M;
    const int N=N1+N2;
    vector G(N,vector<int>());
    for(int i=0;i<M;i++){
        int u,v;
        cin>>u>>v;
        u--,v--;
        G[u].emplace_back(v);
        G[v].emplace_back(u);
    }
    auto bfs=[&](int s,vector<int> &dist){
        queue<int> que;
        que.push(s);
        dist[s]=0;
        while(que.size()){
            int p=que.front();
            que.pop();
            for(auto q:G[p]){
                if(dist[q]>dist[p]+1){
                    dist[q]=dist[p]+1;
                    que.push(q);
                }
            }
        }
    };
    const int INF=1<<30;
    vector<int> dist1(N,INF);
    bfs(0,dist1);
    vector<int> distN(N,INF);
    bfs(N-1,distN);
    int max1=0,maxN=0;
    for(auto e:dist1) if(e!=INF and max1<e) max1=e;
    for(auto e:distN) if(e!=INF and maxN<e) maxN=e;
    cout<<max1+maxN+1<<"\n";
}
```
https://atcoder.jp/contests/abc309/submissions/72637760

---
## H - Flipping and Bonus
https://atcoder.jp/contests/abc261/tasks/abc261_d

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    cin.tie(nullptr)->ios::sync_with_stdio(false);
    int N,M;
    cin>>N>>M;
    vector<int> X(N);
    for(auto &e:X) cin>>e;
    vector<int> bonus(N+1,0);
    for(int i=0;i<M;i++){
        int c,y;
        cin>>c>>y;
        bonus[c]=y;
    }
    const long long INF=1ll<<60;
    vector dp(N+1,vector<long long>(N+1,-INF));
    dp[0][0]=0;
    for(int i=0;i<N;i++){
        for(int j=0;j<=i;j++){
            if(dp[i][j]==-INF) continue;
            dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+X[i]+bonus[j+1]);
            dp[i+1][0]=max(dp[i+1][0],dp[i][j]);
        }
    }
    long long ans=*ranges::max_element(dp[N]);
    cout<<ans<<"\n";
}
```
https://atcoder.jp/contests/abc261/submissions/72637879

---
## I - Go Stone Puzzle
https://atcoder.jp/contests/abc361/tasks/abc361_d

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N;
    string S,T;
    cin>>N>>S>>T;
    S+="..";
    T+="..";
    map<string,int> mp;
    mp[S]=0;
    queue<string> que;
    que.push(S);
    while(que.size()){
        string s=que.front();
        que.pop();
        const int nowval=mp[s];
        int dotidx=0;
        for(int i=0;i<=N;i++) if(s[i]=='.') dotidx=i,i=N;
        for(int i=0;i<=N;i++){
            if(abs(i-dotidx)<=1) continue;
            string t=s;
            swap(t[i],t[dotidx]);
            swap(t[i+1],t[dotidx+1]);
            if(mp.contains(t)) continue;
            mp[t]=nowval+1;
            que.push(t);
        }
    }
    cout<<(mp.contains(T)?mp[T]:-1)<<"\n";
}
```
https://atcoder.jp/contests/abc361/submissions/72636992

---
## J - Dungeon Explore
https://atcoder.jp/contests/abc305/tasks/abc305_f



#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    cin.tie(nullptr)->ios::sync_with_stdio(false);
    int N,M;
    cin>>N>>M;
    vector<int> seen(N+1,false);
    seen[1]=true;
    stack<int> pre;
    int p=1;
    while(true){
        int k;
        cin>>k;
        vector<int> v(k);
        for(auto &e:v) cin>>e;
        int q=-1;
        for(auto e:v){
            if(!seen[e]){
                q=e;
                break;
            }
        }
        if(q==-1){
            q=pre.top();
            pre.pop();
        }else{
            pre.push(p);
        }
        seen[q]=true;
        cout<<q<<endl;
        p=q;
        if(q==N){
            string ok;
            cin>>ok;
            return 0;
        }
    }
}
```
https://atcoder.jp/contests/abc305/submissions/72638826
