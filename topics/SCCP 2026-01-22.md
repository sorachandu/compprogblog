コンテストのリンク:
https://kenkoooo.com/atcoder/#/contest/show/5a033350-3c01-4af0-9b70-3e7119abd133

---

今回のテーマは、「アルゴリズムとデータ構造」で学んだアルゴリズムのうち、競技プログラミング分野でも非常に頻出なものを練習できる回 です

---
## A - Restaurant Queue
https://atcoder.jp/contests/abc402/tasks/abc402_b

問題文で要求されている操作はそれぞれ `enqueue`, `dequeue` に相当していて、データ構造の**Queue**で処理できることがわかります。
具体的には、タイプ1のクエリではメニュー番号 $X$ を`enqueue`し、タイプ2のクエリでは`dequeue`して得られた結果(番号)を出力すればよいです。

`Queue`は大抵の言語の標準ライブラリに収録されているので、それを利用するのが簡便でしょう。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int Q;
    cin>>Q;
    queue<int> que;
    while(Q--){
        int type;
        cin>>type;
        if(type==1){
            int X;
            cin>>X;
            que.push(X);
        }else if(type==2){
            cout<<que.front()<<"\n";
            que.pop();
        }
    }
}
```
https://atcoder.jp/contests/abc402/submissions/72637029

---
##  B - KEYENCE building
https://atcoder.jp/contests/abc227/tasks/abc227_b

問題文中の図が奇妙な見た目をしていますが、結局以下のような問題になっています:
> 整数 $S$ が与えられる。ある正の整数$a$,$b$を用いて $S = 4ab + 3a + 3b$ で表せるか?

$a$, $b$ をそれぞれ $1 \leq a,b \leq S$ の範囲で全探索して、条件を満たすものがあるか判定すればよいです。
これは $O(S^2)$ となりますが、Sは最大で $10^3$ ですから十分高速に判定できます。

この問題を $S_1, \dots ,S_N$ それぞれ解く必要がありますが、Nも小さいので高速に動作します。
とりあえずナイーブな全探索解法を考えると見通しがよくなることがしばしばあります。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    int ans=0;
    for(int i=0;i<N;i++){
        int S;
        cin>>S;
        bool islie=true;
        for(int a=1;a<S;a++){
            for(int b=1;b<S;b++){
                if(4*a*b+3*a+3*b == S){
                    islie=false;
                    a=S; break; // aのループごとbreak
                }
            }
        }
        if(islie) ans++;
    }
    cout<<ans<<"\n";
}
```
https://atcoder.jp/contests/abc227/submissions/72637094

---

ここから難易度がやや上がります。
典型的なアルゴリズムを利用しないと解けない問題になってきます。

---
## C - Abundant Resources
https://atcoder.jp/contests/nikkei2019-final/tasks/nikkei2019_final_a

**累積和**と呼ばれる典型アルゴリズムの練習問題です。

累積和は、長さ $N$ の数列に対して、 $O(N)$ で前計算することにより、任意の区間和を $O(1)$ で取得できるようにする手法です。

詳細を知りたい場合、例えば以下のサイトが参考になるでしょう。
https://algo-logic.info/range-sum-query-without-update/

さて、本問では $k=1, \dots , N$ それぞれについて 長さ $k$ の区間和の最大値を求める必要があります。
これは、累積和を用いて任意の区間和を $O(1)$ で取得できるようにしておくと、各問題が殆どナイーブな全探索の要領で解けることがわかります。

具体的には、長さ $k$ の連続する区間というのは $N-k+1$ 個存在しているので、それらを全探索すればよいです。
それぞれの区間の左端 $i$ を固定し、対応する右端 $i+k$ を取ればそれが長さ $k$ の区間に対応する、といった具合です。
計算量は全体 $O(N^2)$ となって、本問の制約下では十分高速に動作します。

#### 実装例
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N;
    cin>>N;
    vector<long long> A(N);
    for(auto &e:A) cin>>e;
    vector<long long> ac(N+1,0);
    for(int i=0;i<N;i++) ac[i+1]=ac[i]+A[i];
    for(int k=1;k<=N;k++){
        long long ans=0;
        for(int i=0;i<=N-k;i++){
            long long sum=ac[i+k]-ac[i];
            if(ans<sum) ans=sum;
        }
        cout<<ans<<"\n";
    }
}
```
https://atcoder.jp/contests/nikkei2019-final/submissions/72637480

---
## D - Enumerate Sequences
https://atcoder.jp/contests/abc367/tasks/abc367_c

一見すると、出力すべき数列自体はforループを用いれば列挙できそうな見た目をしています。
しかし実際にはN重ループが必要になるので、単にループを書くだけで実装するのは現実的ではありません。

こういった場面では**再帰関数**が有用です。再帰関数を用いてやれば現実的に(簡潔に)実装することができます。

再帰関数の書き方については以下の記事が参考になると思います。
https://drken1215.hatenablog.com/entry/2020/05/04/190252

また、競技プログラミングにおいては **深さ優先探索(DFS)** と再帰関数はしばしば同一視されます。
再帰関数を用いた実装は、不慣れなうちは難しいですが、累積和同様に非常に頻出です。
是非とも練習を重ねて、自分なりの書き方や解釈を見つけてもらえればと思います。

#### 実装例
ここでは、ラムダ式を用いて再帰関数を実装しています。
ラムダ式を用いて実装すると、グローバル変数に変数宣言したり、多くの変数を参照渡ししたりせずとも書けるので、引数がスッキリとして書きやすいと思っています

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int N,K;
    cin>>N>>K;
    vector<int> R(N);
    for(auto &e:R) cin>>e;
    auto dfs=[&](this auto self,vector<int> &A,int r) -> void {
        if(r==N){
            int sum=0;
            for(auto &&e:A) sum+=e;
            if(sum%K==0){
                for(int i=0;i<N;i++) cout<<A[i]<<" \n"[i+1==N];
            }
            return;
        }
        for(int i=1;i<=R[r];i++){
            A.emplace_back(i);
            self(A,r+1);
            A.pop_back();
        }
    };
    vector<int> A{};
    dfs(A,0);
}
```
https://atcoder.jp/contests/abc367/submissions/72637447